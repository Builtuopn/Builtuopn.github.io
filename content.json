[{"title":"微信小程序","date":"2021-02-05T12:35:00.000Z","path":"2021/02/05/WeChat/WeChat/","text":"知识点 1.底部导航栏的切换：tabBar2. 页面之间的跳转：wx.navigateTo3.上传图片chooseImage4.url传值 url: ‘/pages/modify/modify?username=’+this.data.username+’&amp;gender=’+this.data.gender,5.获取表单提交的数据bindsubmit。e.detail.value获取表单的全部数据6. getCurrentPages()获取当前页面栈 var pages = getCurrentPages() var prevPage = pages[pages.length - 2] //返回上一页数据7.wx.navigateBack()关闭当前页面，返回上一页面或多级页面","comments":true,"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://builtuopn.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Java 基础","date":"2021-02-05T12:15:00.000Z","path":"2021/02/05/Java web/JavaWeb/","text":"递归经典例题（赶鸭子）1. 题目分析 ①一个人赶着鸭子去每个村庄卖，每经过一个村子卖去所赶鸭子的一半又一只。这样他经过了七个村子后还剩两只鸭子，问他出发时共赶多少只鸭子？经过每个村子卖出多少只鸭子？由题目可得知当经过第八个村庄时鸭子数量为2，所以利用已知条件由后向前递归计算可较为简便计算出出发时的总数，即第一个村庄的数量。由题意可轻松计算每个村庄卖出的数量。②角谷定理。输入一个自然数，若为偶数，则把它除以2，若为奇数，则把它乘以3加1。经过如此有限次运算后，总可以得到自然数值1。求经过多少次可得到自然数1。如：输入22，输出 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1STEP=16由题意可知应将输入数据分为1，偶数，奇数三种情况，分别进行分支处理。当经过选择递归后，当n 变为1后，程序到达递归出口。 2. 算法构造 3. 算法实现12345678910111213141516171819202122232425262728293031323334353637________________________1________________________public class Sellduck &#123; public static int duckNum(int n ) &#123; if(n&#x3D;&#x3D;8) &#123;&#x2F;&#x2F;递归出口 return 2;&#x2F;&#x2F;第七个村庄以后 剩下两只 &#125; else &#123; return 2*(duckNum(n+1)+1);&#x2F;&#x2F;递归调用 &#125; &#125;public static void SellDuck(int n) &#123;&#x2F;&#x2F;剩下的鸭子数n 调用时输入2 int count &#x3D; 7; for(;count &gt;&#x3D; 1;count--) &#123; System.out.println(&quot;第&quot;+count+&quot;个村子卖的鸭子数为:&quot;+(n+2)); n &#x3D; (n+1) * 2; &#125; System.out.println(&quot;他开始有的鸭子数为：&quot;+n); &#125; public static void main(String[] args) &#123; int num &#x3D; duckNum(1); System.out.println(&quot;总共赶鸭子&quot;+num+&quot;只&quot;); for(int i&#x3D;1 ;i&lt;&#x3D;7;i++) &#123;&#x2F;&#x2F;循环计算每个村庄的具体数目 int all &#x3D; duckNum(i); int sale&#x3D; all&#x2F;2+1;&#x2F;&#x2F;计算卖出鸭子数 int remain&#x3D; all-sale; System.out.println(&quot;经过第&quot;+(i)+&quot;个村庄时卖了&quot;+sale+&quot;只鸭子，还剩&quot;+remain+&quot;只&quot;); SellDuck(2); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940_________________________2_______________________import java.util.Scanner;public class valley_number &#123; static int count&#x3D;0; public static void vall_Num( int n) &#123; if(n&#x3D;&#x3D;1) &#123; count++; System.out.println(n);&#x2F;&#x2F;输出1️后停止递归 System.out.println(&quot;step:&quot;+count); return ;&#x2F;&#x2F;计算结果得到1时到达递归出口 &#125; if(n%2&#x3D;&#x3D;1) &#123; count++; System.out.print(n+&quot; &quot;); n&#x3D;n*3+1;&#x2F;&#x2F;执行计算结果为奇数时的表达式 vall_Num(n);&#x2F;&#x2F;递归 &#125;else &#123; count++; System.out.print(n+&quot; &quot;); n&#x3D;n&#x2F;2;&#x2F;&#x2F;执行计算结果为偶数时的表达式 vall_Num(n); &#125; &#125; public static void main(String[] args) &#123; Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;please input a int Number&quot;); int n&#x3D; sc.nextInt(); vall_Num(n); &#125;&#125; 4. 调试测试 5. 经验总结 通过编程掌握了递归程序设计的方法，更深理解了递归的概念，掌握了递归数学模型的建立，及递归程序和非递归程序之间的转换。具体递归问题分析时应先找出递归关系和递归出口。相同问题下，利用递归求解可减少代码量，但是从性能角度来看，递归函数调用自身 ，将会产生时间和内存空间的消耗，同时也有可能存在一些重复计算，这就造成了效率不高的问题。当调用层次过多时还有可能导致 出现栈溢出的状况。","comments":true,"tags":[{"name":"Java 基础","slug":"Java-基础","permalink":"https://builtuopn.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"}]},{"title":"Linux文件目录及常用命令","date":"2021-02-05T12:15:00.000Z","path":"2021/02/05/Linux/Linux/","text":"1.1文件和目录简介 Linux和windows 文件存储方式不同，Windows有多个根目录（/c/d/e/f）linux 只有一个根目录Linux 根目录： 文件–》 其他–》计算机 根目录：1./bin 二进制文件 2./home 用户目录 3./home/xxx(user) 用户家目录 4./etc 系统配置文件目录 5./root 超级管理员的目录 1.2 Linux终端命令格式 终端：软件控制台，在终端输入命令可快速操作计算机终端命令格式： 命令 [-选项] [-参数] 查看帮助的两种方式 （1）.man 命令【enter】 换行【空格】 翻页f - 下一页b - 上一页q - 退出（2）.help命令 –help 1.3 常用命令— 显示文件及目录 *pwd 显示当前所在的路径*tree 以树状列表方式显示文件夹内容(1)tree 当前目录(2)tree aaa[指定目录]*ls 一列表方式显示 文件夹内容ls -a 显示所有文件（包含隐藏文件） 1.3.1显示文件详细信息 ls两个选项-l 以详细信息的方式显示列表内容-h 以更加人性化的方式显示文件夹内容（文件大小 k MB..） 1.3.2 切换目录##（1）.在图形界面进入该文件目录，鼠标右击显示复选框，选择在终端打开即可进入该目录下 ##（2）cd 命令，切换工作目录 用法：cd 路径 切换到指定路径cd 回到家目录cd ~ 回到家目录cd . 当前目录cd .. 上级目录cd - 上次目录 1.4 常用命令—创建文件和文件夹 mkdir 创建目录 ，递归创建 添加 -p 选项touch 创建一个文件：touch 文件名touch 创建多个文件：touch filename1 filename2gedit 用来打开一个文件并进行编辑##（1）.打开一个文件后，终端进入等待状态##（2）.可以同时编辑多个文件 gedit filename1 filename2 1.4.1 常用命令- 删除文件和目录 rm -&gt;remove删除文件或者目录删除文件： rm filename此命令提供两种选项-i 以交互模式删除 （提示是否确认删除）-f 强制删除不提示删除文件夹 rm -r filename 递归删除目录中的内容 1.4.2 常用命令-文件拷贝 cp -&gt;copy用来拷贝文件或目录拷贝文件 ： cp 原路径 目标路径如： cp ./Javascript/demo.txt ./java/demo2.txt该命令提供如下选项-i 交互模式拷贝-f 强制覆盖不提示-v 显示拷贝过程-a 拷贝原有属性·拷贝目录 cp -r 源路径 目标路径 1.4.3 常用命令-移动 mv -&gt;move1.移动文件或文件夹mv 源路径 目标路径选项可选如下：-i 交互方式进行文件移动-f 强制覆盖不提示-v 显示移动过程注意：移动文件夹不需要加 -r 选项2.重命名文件及文件夹重命名： 在一个目录下移动才能进行重命名mv 旧文件名 新文件名 1.5 常用命令-其他 clear清除当前终端显示内容 如果你想秀操作的话 使用快捷键 【ctrl】+【l】 【Tab】自动补全文件夹或者文件名注意：当在当前文件夹下有相同开头文件名时，补全功能无法实现，此时按两下Tab 系统显示当前文件夹下的所有以所写命令开始的文件名 which查看某个命令所在的位置如： which gedit 终止指令的执行【ctrl】+【c】 终端字体的大小调整放大： ctrl +shift+=缩小： ctrl+ - 1.6 常用命令-日历日期 cal 查看日历cal -3 查看上月，当前月，下一月cal -y 显示当年的日历cal -j 以一年中第—天的形式显示日历cal + 具体年份 显示所写年份日历date 查看日期时间date 显示当前的年月日时分秒格式化显示date ”+%Y” 输出年份date ”+%m” 输出月份date ”+%d” 输出天date ”+%H” 输出时date ”+%M” 输出分date ”+%S” 输出秒date ”+%F” 格式化输出 如2019-7-19date ”+%T” 格式化输出 如19：56：21 1.7 常用命令-查看历史指令 history 查看当前用户服务器所有历史指令history 数量 显示一定数量的历史指令！历史指令编号 执行该条历史指令历史指令保存在~/.bash_history 文件中 1.8常用命令-文件查看（cat ,more） ·cat 查看文件或连接文件| 1.查看文件cat 文件名选项：-n 查看文件时，对每一行进行编号-b 非空行进行编号-s 连续两行以上的空行，只显示一行| 2.连接文件，把两个文件合并到 一起进行输出cat filename1 filename2·more 用来分屏查看文件内容选项：+num 从第num行开始查看文件 如：more ./demo.txt +20-p 先清屏，再查看文件-s 连续两行以上的空行，只显示一行快捷键：【enter】查看下一行【空格】查看下一屏Ctrl + f 查看下一屏Ctrl + b 查看上一屏q 退出 1.9 常用命令-数据流 、管道 ·数据流 输入流输出流标准的错误输入输出流·重定向：改变数据流向（一般定向到文件中） 重定向 以追加的方式重定向 ·管道 | 指令1 |指令2 ps:指令1必须要有输出如： touch demo.txt |more 因为指令1无输出，所以该管道使用错误","comments":true,"tags":[{"name":"Linux","slug":"Linux","permalink":"https://builtuopn.github.io/tags/Linux/"}]},{"title":"Spring boot","date":"2021-02-05T12:15:00.000Z","path":"2021/02/05/Spring boot/Spring boot/","text":"SpringBoot是由Pivotal团队在2013年开始研发、2014年4月发布第一个版本的全新开源的轻量级框架。它基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。 分层 （数据访问层）Mapper层：添加@Mapper注解，写数据库操作的方法（实现对数据库的操作）（业务层）Service层：添加@Service注解，编写与Mapper方法一样的方法（一般跟Mapper的方法一样）Serviceimpl接口实现类：实现Service接口，实现Service的方法，调用Mapper的方法，需要使用@Autowrie注入Mapper,调用方法（控制层）Controller层：调用Service层的方法，要使用@Autowrie注入Service,调用其方法。 SpringBoot+Mybatis+SpringMVC整合 mapper层 Controller层 Service层 业务层实现类ServiceImpl 视图层","comments":true,"tags":[{"name":"Spring boot","slug":"Spring-boot","permalink":"https://builtuopn.github.io/tags/Spring-boot/"}]},{"title":"MySQL常用语句总结","date":"2021-02-04T17:15:10.000Z","path":"2021/02/05/title/","text":"查看现有数据库 SHOW DATABASES; 新建数据库 CREATE DATABASE &lt;数据库名&gt;; 选择数据库 USE &lt;数据库名&gt;; 从.sql文件引入SQL语句 SOURCE &lt;.sql文件路径&gt;; 删除数据库 DROP DATABASE &lt;数据库名&gt;; 查看当前数据库中的表 SHOW TABLES; 创建新表 12345678CREATE TABLE &lt;表名&gt; (&lt;列名1&gt; &lt;列类型1&gt;,&lt;列名2&gt; &lt;列类型2&gt;,&lt;列名3&gt; &lt;列类型3&gt;,PRIMARY KEY (&lt;列名1&gt;),FOREIGN KEY (&lt;列名2&gt;) REFERENCES &lt;表名2&gt;(&lt;列名2&gt;)); 主键（PRIMARY KEY）用来标识一条记录（一行），所以每条记录的主键值必须是唯一的。主键可以定义在多列上，这称为联合主键（composite primary key）。如果我们把表视作具有某种结构的数组（例如，C语言中的struct），那么外键（FOREIGN KEY）可以视作指针 例子： 123456789CREATE TABLE instructor ( ID CHAR(5), name VARCHAR(20) NOT NULL, dept_name VARCHAR(20), salary NUMERIC(8,2), PRIMARY KEY (ID), FOREIGN KEY (dept_name) REFERENCES department(dept_name) ); 在上面的例子中，我们创建了一个教员（instructor）表，该表的主键是ID，外键是教员所在的部门名称（dept_name），关联部门（department）表。此外，教员表还包括姓名（name）、薪水（salary）。其中，姓名有约束NOT NULL，表示姓名这一项不能为空。 概述表中的列使用如下语句查看表中的列的基本信息： DESCRIBE &lt;表名&gt;; 下图显示了一些例子： 在表中插入新纪录 INSERT INTO &lt;表名&gt; (&lt;列名1&gt;, &lt;列名2&gt;, &lt;列名3&gt;, …)VALUES (&lt;值1&gt;, &lt;值2&gt;, &lt;值3&gt;, …); 在表中更新记录 123UPDATE &lt;表名&gt; SET &lt;列名1&gt; &#x3D; &lt;值1&gt;, &lt;列名2&gt; &#x3D; &lt;值2&gt;, ... WHERE &lt;条件&gt;; 清空表 DELETE FROM &lt;表名&gt;; 删除表 DROP TABLE &lt;表名&gt;; SELECTSELECT语句可以从表中选择数据： 12SELECT &lt;列名1&gt;, &lt;列名2&gt;, …FROM &lt;表名&gt;; 以下语句选择所有内容： SELECT * FROM &lt;表名&gt;; SELECT DISTINCTSELECT DISTINCT过滤掉了重复的值： 12SELECT DISTINCT &lt;列名1&gt;, &lt;列名2&gt;, …FROM &lt;表名&gt;; WHERE我们之前在更新记录时已经用到了WHERE关键字，用来指明条件。这里我们稍微详细一点地介绍下WHERE。WHERE的条件通常是：比较文本（text）比较数字（numbers）AND、OR、NOT等逻辑运算让我们来看一些例子： 123SELECT * FROM course WHERE dept_name&#x3D;&#39;Comp. Sci.&#39;;SELECT * FROM course WHERE credits&gt;3;SELECT * FROM course WHERE dept_name&#x3D;&#39;Comp. Sci.&#39; AND credits&gt;3; GROUP BYGROUP BY语句可以分组结果，常用于COUNT、MAX、MIN、SUM、AVG等聚合函数（aggregate functions）。 123SELECT &lt;列名1&gt;, &lt;列名2&gt;, …FROM &lt;表名&gt;GROUP BY &lt;列名&gt;; 让我们来看一个例子，列出每个部门的课程数量： 123SELECT COUNT(course_id), dept_name FROM course GROUP BY dept_name; HAVING乍看起来，HAVING和WHERE很像： 1234SELECT &lt;列名1&gt;, &lt;列名2&gt;, …FROM &lt;表名&gt;GROUP BY &lt;列名x&gt;HAVING &lt;条件&gt;; 那么，HAVING和WHERE有什么不同呢？让我们先来看一个例子，列出开了不止一门课程的部门开设的课程数： 1234 SELECT COUNT(course_id), dept_name FROM course GROUP BY dept_name HAVING COUNT(course_id)&gt;1; 这里HAVING不能换成WHERE，因为WHERE直接针对行操作，且在GROUP BY之前运行（即先通过WHERE筛选行，之后再将筛选出的行通过GROUP BY分组）。假设SQL中不存在HAVING语句，那么我们只能先新建一张表，将COUNT(course_id)作为新表的列，然后在新表上再通过WHERE进行筛选（当然，实际上SQL提供了派生表、CTE等机制，并不用真的手工建新表）。 ORDER BYORDER BY可以对结果进行排序，在没有明确指定ASC（升序）或DESC（降序）的情况下，默认按升序排列。 123SELECT &lt;列名1&gt;, &lt;列名2&gt;, …FROM &lt;表名&gt;ORDER BY &lt;列名1&gt;, &lt;列名2&gt;, …, ASC|DESC; 例子： 12SELECT * FROM course ORDER BY credits;SELECT * FROM course ORDER BY credits DESC; BETWEENBETWEEN语句用于指定区间。 123SELECT &lt;列名1&gt;, &lt;列名2&gt;, … FROM &lt;表名&gt; WHERE &lt;列名x&gt; BETWEEN &lt;值1&gt; AND &lt;值2&gt;; 其中“值”可能是数字，文本，乃至日期等。例如，列出薪资在50000和100000之间的教员： SELECT * FROM instructor WHERE salary BETWEEN 50000 AND 100000; LIKELIKE用于匹配文本中的特定模式。 123SELECT &lt;列名1&gt;, &lt;列名2&gt;, … FROM &lt;表名&gt; WHERE &lt;列名x&gt; LIKE &lt;模式&gt;; 模式中可以使用以下两个通配符：% （零个、一个或多个字符）_ （单个字符） 例子：列出课程名中包含“to”的课程，以及课程ID以“CS-”开头的课程。 12SELECT * FROM course WHERE title LIKE &#39;%to%&#39;;SELECT * FROM course WHERE course_id LIKE &#39;CS-___&#39;; ININ语句表示值属于某个集合。 123SELECT &lt;列名1&gt;, &lt;列名2&gt;, … FROM &lt;表名&gt; WHERE &lt;列名n&gt; IN (&lt;值1&gt;, &lt;值2&gt;, …); 例子：列出计算机科学、物理、电子工程部门的学生。 SELECT * FROM student WHERE dept_name IN (&#39;Comp. Sci.&#39;, &#39;Physics&#39;, &#39;Elec. Eng.&#39;); JOINJOIN用来组合两张以上表中的值。下图展示了JOIN的三种类型： 1234SELECT &lt;列名1&gt;, &lt;列名2&gt;, … FROM &lt;表名1&gt; JOIN &lt;表名2&gt; ON &lt;表名1.列名x&gt; &#x3D; &lt;表名2.列名x&gt; 让我们来看三个例子，分别对应三种JOIN的类型。 第一个例子，列出课程时包含开设课程的部门详情： 123SELECT * FROM course JOIN department ON course.dept_name&#x3D;department.dept_name; 第二个例子，列出所有具有前置课程的课程的详情： 1234SELECT prereq.course_id, title, dept_name, credits, prereq_id FROM prereq LEFT OUTER JOIN course ON prereq.course_id&#x3D;course.course_id; 最后一个例子，列出所有课程的详情，不管是否具有前置课程： 1234SELECT course.course_id, title, dept_name, credits, prereq_id FROM prereq RIGHT OUTER JOIN course ON prereq.course_id&#x3D;course.course_id; 视图视图（view）是虚拟的SQL表。它包含行和列，和一般的SQL表格很类似。视图总是显示数据库中的最新数据。 CREATE VIEW 创建视图： 1234CREATE VIEW &lt;视图名&gt; AS SELECT &lt;列名1&gt;, &lt;列名2&gt;, … FROM &lt;表名&gt; WHERE &lt;条件&gt;; 删除视图： DROP VIEW &lt;视图名&gt;; 例如，创建3学分的课程视图： 123CREATE VIEW my_view AS SELECT * FROM course WHERE credits&#x3D;3; 聚合函数我们之前已经提到聚合函数，这里列出最常用的一些聚合函数： COUNT(列名) 返回行数 SUM(列名) 返回指定列的值之和 AVG(列名) 返回指定列的平均值 MIN(列名) 返回指定列的最小值 MAX(列名) 返回指定列的最大值 嵌套子查询在SQL请求中，可以嵌套SELECT-FROM-WHERE表达式，称为嵌套子查询（nested subqueries）。例如，查找2009年秋、2010年春都开的课程： 1234567SELECT DISTINCT course_id FROM section WHERE semester &#x3D; ‘Fall’ AND year&#x3D; 2009 AND course_id IN ( SELECT course_id FROM section WHERE semester &#x3D; ‘Spring’ AND year&#x3D; 2010);","comments":true,"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://builtuopn.github.io/tags/MySQL/"}]}]