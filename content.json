[{"title":"MySQL常用语句总结","date":"2021-02-04T17:15:10.000Z","path":"2021/02/05/title/","text":"查看现有数据库 SHOW DATABASES; 新建数据库 CREATE DATABASE &lt;数据库名&gt;; 选择数据库 USE &lt;数据库名&gt;; 从.sql文件引入SQL语句 SOURCE &lt;.sql文件路径&gt;; 删除数据库 DROP DATABASE &lt;数据库名&gt;; 查看当前数据库中的表 SHOW TABLES; 创建新表 12345678CREATE TABLE &lt;表名&gt; (&lt;列名1&gt; &lt;列类型1&gt;,&lt;列名2&gt; &lt;列类型2&gt;,&lt;列名3&gt; &lt;列类型3&gt;,PRIMARY KEY (&lt;列名1&gt;),FOREIGN KEY (&lt;列名2&gt;) REFERENCES &lt;表名2&gt;(&lt;列名2&gt;)); 主键（PRIMARY KEY）用来标识一条记录（一行），所以每条记录的主键值必须是唯一的。主键可以定义在多列上，这称为联合主键（composite primary key）。如果我们把表视作具有某种结构的数组（例如，C语言中的struct），那么外键（FOREIGN KEY）可以视作指针 例子： 123456789CREATE TABLE instructor ( ID CHAR(5), name VARCHAR(20) NOT NULL, dept_name VARCHAR(20), salary NUMERIC(8,2), PRIMARY KEY (ID), FOREIGN KEY (dept_name) REFERENCES department(dept_name) ); 在上面的例子中，我们创建了一个教员（instructor）表，该表的主键是ID，外键是教员所在的部门名称（dept_name），关联部门（department）表。此外，教员表还包括姓名（name）、薪水（salary）。其中，姓名有约束NOT NULL，表示姓名这一项不能为空。 概述表中的列使用如下语句查看表中的列的基本信息： DESCRIBE &lt;表名&gt;; 下图显示了一些例子： 在表中插入新纪录 INSERT INTO &lt;表名&gt; (&lt;列名1&gt;, &lt;列名2&gt;, &lt;列名3&gt;, …)VALUES (&lt;值1&gt;, &lt;值2&gt;, &lt;值3&gt;, …); 在表中更新记录 123UPDATE &lt;表名&gt; SET &lt;列名1&gt; &#x3D; &lt;值1&gt;, &lt;列名2&gt; &#x3D; &lt;值2&gt;, ... WHERE &lt;条件&gt;; 清空表 DELETE FROM &lt;表名&gt;; 删除表 DROP TABLE &lt;表名&gt;; SELECTSELECT语句可以从表中选择数据： 12SELECT &lt;列名1&gt;, &lt;列名2&gt;, …FROM &lt;表名&gt;; 以下语句选择所有内容： SELECT * FROM &lt;表名&gt;; SELECT DISTINCTSELECT DISTINCT过滤掉了重复的值： 12SELECT DISTINCT &lt;列名1&gt;, &lt;列名2&gt;, …FROM &lt;表名&gt;; WHERE我们之前在更新记录时已经用到了WHERE关键字，用来指明条件。这里我们稍微详细一点地介绍下WHERE。WHERE的条件通常是：比较文本（text）比较数字（numbers）AND、OR、NOT等逻辑运算让我们来看一些例子： 123SELECT * FROM course WHERE dept_name&#x3D;&#39;Comp. Sci.&#39;;SELECT * FROM course WHERE credits&gt;3;SELECT * FROM course WHERE dept_name&#x3D;&#39;Comp. Sci.&#39; AND credits&gt;3; GROUP BYGROUP BY语句可以分组结果，常用于COUNT、MAX、MIN、SUM、AVG等聚合函数（aggregate functions）。 123SELECT &lt;列名1&gt;, &lt;列名2&gt;, …FROM &lt;表名&gt;GROUP BY &lt;列名&gt;; 让我们来看一个例子，列出每个部门的课程数量： 123SELECT COUNT(course_id), dept_name FROM course GROUP BY dept_name; HAVING乍看起来，HAVING和WHERE很像： 1234SELECT &lt;列名1&gt;, &lt;列名2&gt;, …FROM &lt;表名&gt;GROUP BY &lt;列名x&gt;HAVING &lt;条件&gt;; 那么，HAVING和WHERE有什么不同呢？让我们先来看一个例子，列出开了不止一门课程的部门开设的课程数： 1234 SELECT COUNT(course_id), dept_name FROM course GROUP BY dept_name HAVING COUNT(course_id)&gt;1; 这里HAVING不能换成WHERE，因为WHERE直接针对行操作，且在GROUP BY之前运行（即先通过WHERE筛选行，之后再将筛选出的行通过GROUP BY分组）。假设SQL中不存在HAVING语句，那么我们只能先新建一张表，将COUNT(course_id)作为新表的列，然后在新表上再通过WHERE进行筛选（当然，实际上SQL提供了派生表、CTE等机制，并不用真的手工建新表）。 ORDER BYORDER BY可以对结果进行排序，在没有明确指定ASC（升序）或DESC（降序）的情况下，默认按升序排列。 123SELECT &lt;列名1&gt;, &lt;列名2&gt;, …FROM &lt;表名&gt;ORDER BY &lt;列名1&gt;, &lt;列名2&gt;, …, ASC|DESC; 例子： 12SELECT * FROM course ORDER BY credits;SELECT * FROM course ORDER BY credits DESC; BETWEENBETWEEN语句用于指定区间。 123SELECT &lt;列名1&gt;, &lt;列名2&gt;, … FROM &lt;表名&gt; WHERE &lt;列名x&gt; BETWEEN &lt;值1&gt; AND &lt;值2&gt;; 其中“值”可能是数字，文本，乃至日期等。例如，列出薪资在50000和100000之间的教员： SELECT * FROM instructor WHERE salary BETWEEN 50000 AND 100000; LIKELIKE用于匹配文本中的特定模式。 123SELECT &lt;列名1&gt;, &lt;列名2&gt;, … FROM &lt;表名&gt; WHERE &lt;列名x&gt; LIKE &lt;模式&gt;; 模式中可以使用以下两个通配符：% （零个、一个或多个字符）_ （单个字符） 例子：列出课程名中包含“to”的课程，以及课程ID以“CS-”开头的课程。 12SELECT * FROM course WHERE title LIKE &#39;%to%&#39;;SELECT * FROM course WHERE course_id LIKE &#39;CS-___&#39;; ININ语句表示值属于某个集合。 123SELECT &lt;列名1&gt;, &lt;列名2&gt;, … FROM &lt;表名&gt; WHERE &lt;列名n&gt; IN (&lt;值1&gt;, &lt;值2&gt;, …); 例子：列出计算机科学、物理、电子工程部门的学生。 SELECT * FROM student WHERE dept_name IN (&#39;Comp. Sci.&#39;, &#39;Physics&#39;, &#39;Elec. Eng.&#39;); JOINJOIN用来组合两张以上表中的值。下图展示了JOIN的三种类型： 1234SELECT &lt;列名1&gt;, &lt;列名2&gt;, … FROM &lt;表名1&gt; JOIN &lt;表名2&gt; ON &lt;表名1.列名x&gt; &#x3D; &lt;表名2.列名x&gt; 让我们来看三个例子，分别对应三种JOIN的类型。 第一个例子，列出课程时包含开设课程的部门详情： 123SELECT * FROM course JOIN department ON course.dept_name&#x3D;department.dept_name; 第二个例子，列出所有具有前置课程的课程的详情： 1234SELECT prereq.course_id, title, dept_name, credits, prereq_id FROM prereq LEFT OUTER JOIN course ON prereq.course_id&#x3D;course.course_id; 最后一个例子，列出所有课程的详情，不管是否具有前置课程： 1234SELECT course.course_id, title, dept_name, credits, prereq_id FROM prereq RIGHT OUTER JOIN course ON prereq.course_id&#x3D;course.course_id; 视图视图（view）是虚拟的SQL表。它包含行和列，和一般的SQL表格很类似。视图总是显示数据库中的最新数据。 CREATE VIEW 创建视图： 1234CREATE VIEW &lt;视图名&gt; AS SELECT &lt;列名1&gt;, &lt;列名2&gt;, … FROM &lt;表名&gt; WHERE &lt;条件&gt;; 删除视图： DROP VIEW &lt;视图名&gt;; 例如，创建3学分的课程视图： 123CREATE VIEW my_view AS SELECT * FROM course WHERE credits&#x3D;3; 聚合函数我们之前已经提到聚合函数，这里列出最常用的一些聚合函数： COUNT(列名) 返回行数 SUM(列名) 返回指定列的值之和 AVG(列名) 返回指定列的平均值 MIN(列名) 返回指定列的最小值 MAX(列名) 返回指定列的最大值 嵌套子查询在SQL请求中，可以嵌套SELECT-FROM-WHERE表达式，称为嵌套子查询（nested subqueries）。例如，查找2009年秋、2010年春都开的课程： 1234567SELECT DISTINCT course_id FROM section WHERE semester &#x3D; ‘Fall’ AND year&#x3D; 2009 AND course_id IN ( SELECT course_id FROM section WHERE semester &#x3D; ‘Spring’ AND year&#x3D; 2010);","comments":true,"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://builtuopn.github.io/tags/MySQL/"}]}]