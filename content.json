[{"title":"Linux 命令 --- man","date":"2021-02-06T12:00:00.000Z","path":"2021/02/06/Linux/Linux02/","text":"man 命令可以说是初学 Linux 系统最应该接触的命令了。使用 man 命令，你几乎可以查看任何命令的用户手册简介man 命令的全称叫 “manual”, 是 Linux 下的帮助指令，可用于查看 Linux 中各种指令的帮助信息 语法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576用法： man [选项...] [章节] 手册页... -C, --config-file=文件 使用该用户设置文件 -d, --debug 输出调试信息 -D, --default 将所有选项都重置为默认值 --warnings[=警告] 开启 groff 的警告 主要运行模式： -f, --whatis 等同于 whatis -k, --apropos 等同于 apropos -K, --global-apropos 在所有页面中搜索文字 -l, --local-file 把“手册页”参数当成本地文件名来解读 -w, --where, --path, --location 输出手册页的物理位置 -W, --where-cat, --location-cat 输出 cat 文件的物理位置 -c, --catman 由 catman 使用，用来对过时的 cat 页重新排版 -R, --recode=编码 以指定编码输出手册页源码 寻找手册页： -L, --locale=区域 定义本次手册页搜索所采用的区域设置 -m, --systems=系统 使用来自其它系统的手册页 -M, --manpath=路径 设置搜索手册页的路径为 PATH -S, -s, --sections=列表 使用以半角冒号分隔的章节列表 -e, --extension=扩展 将搜索限制在扩展类型为“扩展”的手册页之内 -i, --ignore-case 查找手册页时不区分大小写字母 (默认) -I, --match-case 查找手册页时区分大小写字母 --regex 显示所有匹配正则表达式的页面 --wildcard 显示所有匹配通配符的页面 --names-only 使得 --regex 和 --wildcard 仅匹配页面名称，不匹配描述信息 -a, --all 寻找所有匹配的手册页 -u, --update 强制进行缓存一致性的检查 --no-subpages 不要尝试子页面，如“man foo bar” =&gt; “man foo-bar” 控制格式化的输出： -P, --pager=PAGER 使用 PAGER 程序显示输出文本 -r, --prompt=字符串 给 less 分页器提供一个提示行 -7, --ascii 显示某些 latin1 字符的 ASCII 翻译形式 -E, --encoding=编码 使用选中的输出编码 --no-hyphenation, --nh 关闭连字符 --no-justification, --nj 禁止两端对齐 -p, --preprocessor=字符串 字符串表示要运行哪些预处理器： e - [n]eqn, p - pic, t - tbl,g - grap, r - refer, v - vgrind -t, --troff 使用 groff 对手册页排版 -T, --troff-device[=设备] 使用 groff 的指定设备 -H, --html[=浏览器] 使用 www-browser 或指定浏览器显示 HTML 输出 -X, --gxditview[=分辨率] 使用 groff 并通过 gxditview (X11) 来显示： -X = -TX75, -X100 = -TX100, -X100-12 = -TX100-12 -Z, --ditroff 使用 groff 并强制它生成 ditroff -?, --help 显示此帮助列表 --usage 显示一份简洁的用法信息 -V, --version 打印程序版本选项完整形式所必须用的或是可选的参数，在使用选项缩写形式时也是必须的或是可选的 示例使用 man 命令查看 man 命令自己的用户手册 1man man 执行效果:","comments":true,"tags":[{"name":"Linux","slug":"Linux","permalink":"https://builtuopn.github.io/tags/Linux/"}]},{"title":"微信小程序","date":"2021-02-05T12:35:00.000Z","path":"2021/02/05/WeChat/WeChat/","text":"小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。小程序技术发展史​小程序并非凭空冒出来的一个概念。当微信中的 WebView 逐渐成为移动 Web 的一个重要入口时，微信就有相关的 JS API 了。小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。 知识点 1.底部导航栏的切换：tabBar2. 页面之间的跳转：wx.navigateTo3.上传图片chooseImage4.url传值 url: ‘/pages/modify/modify?username=’+this.data.username+’&amp;gender=’+this.data.gender,5.获取表单提交的数据bindsubmit。e.detail.value获取表单的全部数据6. getCurrentPages()获取当前页面栈 var pages = getCurrentPages() var prevPage = pages[pages.length - 2] //返回上一页数据7.wx.navigateBack()关闭当前页面，返回上一页面或多级页面 swiper滑块视图容器。其中只可放置swiper-item组件，否则会导致未定义的行为。wxml 代码12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;view class=&quot;container&quot;&gt; &lt;view class=&quot;page-body&quot;&gt; &lt;view class=&quot;page-section page-section-spacing swiper&quot;&gt; &lt;swiper indicator-dots=&quot;&#123;&#123;indicatorDots&#125;&#125;&quot; autoplay=&quot;&#123;&#123;autoplay&#125;&#125;&quot; interval=&quot;&#123;&#123;interval&#125;&#125;&quot; duration=&quot;&#123;&#123;duration&#125;&#125;&quot;&gt; &lt;block wx:for=&quot;&#123;&#123;background&#125;&#125;&quot; wx:key=&quot;*this&quot;&gt; &lt;swiper-item&gt; &lt;view class=&quot;swiper-item &#123;&#123;item&#125;&#125;&quot;&gt;&lt;/view&gt; &lt;/swiper-item&gt; &lt;/block&gt; &lt;/swiper&gt; &lt;/view&gt; &lt;view class=&quot;page-section&quot; style=&quot;margin-top: 40rpx;margin-bottom: 0;&quot;&gt; &lt;view class=&quot;weui-cells weui-cells_after-title&quot;&gt; &lt;view class=&quot;weui-cell weui-cell_switch&quot;&gt; &lt;view class=&quot;weui-cell__bd&quot;&gt;指示点&lt;/view&gt; &lt;view class=&quot;weui-cell__ft&quot;&gt; &lt;switch checked=&quot;&#123;&#123;indicatorDots&#125;&#125;&quot; bindchange=&quot;changeIndicatorDots&quot; /&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;weui-cell weui-cell_switch&quot;&gt; &lt;view class=&quot;weui-cell__bd&quot;&gt;自动播放&lt;/view&gt; &lt;view class=&quot;weui-cell__ft&quot;&gt; &lt;switch checked=&quot;&#123;&#123;autoplay&#125;&#125;&quot; bindchange=&quot;changeAutoplay&quot; /&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;page-section page-section-spacing&quot;&gt; &lt;view class=&quot;page-section-title&quot;&gt; &lt;text&gt;幻灯片切换时长(ms)&lt;/text&gt; &lt;text class=&quot;info&quot;&gt;&#123;&#123;duration&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;slider bindchange=&quot;durationChange&quot; value=&quot;&#123;&#123;duration&#125;&#125;&quot; min=&quot;500&quot; max=&quot;2000&quot;/&gt; &lt;view class=&quot;page-section-title&quot;&gt; &lt;text&gt;自动播放间隔时长(ms)&lt;/text&gt; &lt;text class=&quot;info&quot;&gt;&#123;&#123;interval&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;slider bindchange=&quot;intervalChange&quot; value=&quot;&#123;&#123;interval&#125;&#125;&quot; min=&quot;2000&quot; max=&quot;10000&quot;/&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; js 代码Page(&#123; onShareAppMessage() &#123; return &#123; title: &#39;swiper&#39;, path: &#39;page/component/pages/swiper/swiper&#39; &#125; &#125;, data: &#123; background: [&#39;demo-text-1&#39;, &#39;demo-text-2&#39;, &#39;demo-text-3&#39;], indicatorDots: true, vertical: false, autoplay: false, interval: 2000, duration: 500 &#125;, changeIndicatorDots() &#123; this.setData(&#123; indicatorDots: !this.data.indicatorDots &#125;) &#125;, changeAutoplay() &#123; this.setData(&#123; autoplay: !this.data.autoplay &#125;) &#125;, intervalChange(e) &#123; this.setData(&#123; interval: e.detail.value &#125;) &#125;, durationChange(e) &#123; this.setData(&#123; duration: e.detail.value &#125;) &#125; &#125;), 效果图","comments":true,"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://builtuopn.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Java 基础","date":"2021-02-05T12:15:00.000Z","path":"2021/02/05/Java/Java/","text":"递归经典例题（赶鸭子）1. 题目分析 ①一个人赶着鸭子去每个村庄卖，每经过一个村子卖去所赶鸭子的一半又一只。这样他经过了七个村子后还剩两只鸭子，问他出发时共赶多少只鸭子？经过每个村子卖出多少只鸭子？由题目可得知当经过第八个村庄时鸭子数量为2，所以利用已知条件由后向前递归计算可较为简便计算出出发时的总数，即第一个村庄的数量。由题意可轻松计算每个村庄卖出的数量。②角谷定理。输入一个自然数，若为偶数，则把它除以2，若为奇数，则把它乘以3加1。经过如此有限次运算后，总可以得到自然数值1。求经过多少次可得到自然数1。如：输入22，输出 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1STEP=16由题意可知应将输入数据分为1，偶数，奇数三种情况，分别进行分支处理。当经过选择递归后，当n 变为1后，程序到达递归出口。 2. 算法构造 3. 算法实现12345678910111213141516171819202122232425262728293031323334353637________________________1________________________public class Sellduck &#123; public static int duckNum(int n ) &#123; if(n==8) &#123;//递归出口 return 2;//第七个村庄以后 剩下两只 &#125; else &#123; return 2*(duckNum(n+1)+1);//递归调用 &#125; &#125;public static void SellDuck(int n) &#123;//剩下的鸭子数n 调用时输入2 int count = 7; for(;count &gt;= 1;count--) &#123; System.out.println(&quot;第&quot;+count+&quot;个村子卖的鸭子数为:&quot;+(n+2)); n = (n+1) * 2; &#125; System.out.println(&quot;他开始有的鸭子数为：&quot;+n); &#125; public static void main(String[] args) &#123; int num = duckNum(1); System.out.println(&quot;总共赶鸭子&quot;+num+&quot;只&quot;); for(int i=1 ;i&lt;=7;i++) &#123;//循环计算每个村庄的具体数目 int all = duckNum(i); int sale= all/2+1;//计算卖出鸭子数 int remain= all-sale; System.out.println(&quot;经过第&quot;+(i)+&quot;个村庄时卖了&quot;+sale+&quot;只鸭子，还剩&quot;+remain+&quot;只&quot;); SellDuck(2); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940_________________________2_______________________import java.util.Scanner;public class valley_number &#123; static int count=0; public static void vall_Num( int n) &#123; if(n==1) &#123; count++; System.out.println(n);//输出1️后停止递归 System.out.println(&quot;step:&quot;+count); return ;//计算结果得到1时到达递归出口 &#125; if(n%2==1) &#123; count++; System.out.print(n+&quot; &quot;); n=n*3+1;//执行计算结果为奇数时的表达式 vall_Num(n);//递归 &#125;else &#123; count++; System.out.print(n+&quot; &quot;); n=n/2;//执行计算结果为偶数时的表达式 vall_Num(n); &#125; &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;please input a int Number&quot;); int n= sc.nextInt(); vall_Num(n); &#125;&#125; 4. 调试测试 5. 经验总结 通过编程掌握了递归程序设计的方法，更深理解了递归的概念，掌握了递归数学模型的建立，及递归程序和非递归程序之间的转换。具体递归问题分析时应先找出递归关系和递归出口。相同问题下，利用递归求解可减少代码量，但是从性能角度来看，递归函数调用自身 ，将会产生时间和内存空间的消耗，同时也有可能存在一些重复计算，这就造成了效率不高的问题。当调用层次过多时还有可能导致 出现栈溢出的状况。","comments":true,"tags":[{"name":"Java 基础","slug":"Java-基础","permalink":"https://builtuopn.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"}]},{"title":"Spring boot","date":"2021-02-05T12:15:00.000Z","path":"2021/02/05/Spring boot/Spring boot/","text":"SpringBoot是由Pivotal团队在2013年开始研发、2014年4月发布第一个版本的全新开源的轻量级框架。它基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。 IDEA 下为 Spring Boot 项目开启热部署前言 因为最近接触了一丢丢 Spring Boot 下的 Web 开发学习，每次进行一丢丢改动都要重启项目甚是麻烦。所以查了一下 IDEA 下 Spring 项目开启热部署的方法，特此记录，以便查阅. 修改 pom 文件1.在 dependency 中添加 optional 属性并设置为 true: 1234567 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.在 plugin 中配置属性 fork 并设置为 true: 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 配置 IDEA3.进入设置界面，选择 “Build, Execution, Deployment” 下的 “Compiler” 选项，勾选右边的 “Build project automatically”;4.使用快捷键 Ctrl + Shift + A 并搜索 “Registry”. 进入 “Registry” 界面后找到 “compile.automake.allow.when.app.running” 并勾选至此，热部署就设置好啦. 分层 （数据访问层）Mapper层：添加@Mapper注解，写数据库操作的方法（实现对数据库的操作）（业务层）Service层：添加@Service注解，编写与Mapper方法一样的方法（一般跟Mapper的方法一样）Serviceimpl接口实现类：实现Service接口，实现Service的方法，调用Mapper的方法，需要使用@Autowrie注入Mapper,调用方法（控制层）Controller层：调用Service层的方法，要使用@Autowrie注入Service,调用其方法。 SpringBoot+Mybatis+SpringMVC整合 mapper层 Controller层 Service层 业务层实现类ServiceImpl 视图层","comments":true,"tags":[{"name":"Spring boot","slug":"Spring-boot","permalink":"https://builtuopn.github.io/tags/Spring-boot/"}]},{"title":"Linux文件目录及常用命令","date":"2021-02-05T12:15:00.000Z","path":"2021/02/05/Linux/Linux/","text":"1.1文件和目录简介 Linux，全称GNU/Linux，是一种免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。Linux有上百种不同的发行版，如基于社区开发的debian、archlinux，和基于商业开发的Red Hat Enterprise Linux、SUSE、Oracle Linux等。Linux和windows 文件存储方式不同，Windows有多个根目录（/c/d/e/f）linux 只有一个根目录Linux 根目录： 文件–》 其他–》计算机 根目录：1./bin 二进制文件 2./home 用户目录 3./home/xxx(user) 用户家目录 4./etc 系统配置文件目录 5./root 超级管理员的目录 1.2 Linux终端命令格式 终端：软件控制台，在终端输入命令可快速操作计算机终端命令格式： 命令 [-选项] [-参数] 查看帮助的两种方式 （1）.man 命令【enter】 换行【空格】 翻页f - 下一页b - 上一页q - 退出（2）.help命令 –help 1.3 常用命令— 显示文件及目录 *pwd 显示当前所在的路径*tree 以树状列表方式显示文件夹内容(1)tree 当前目录(2)tree aaa[指定目录]*ls 一列表方式显示 文件夹内容ls -a 显示所有文件（包含隐藏文件） 1.3.1显示文件详细信息 ls两个选项-l 以详细信息的方式显示列表内容-h 以更加人性化的方式显示文件夹内容（文件大小 k MB..） 1.3.2 切换目录##（1）.在图形界面进入该文件目录，鼠标右击显示复选框，选择在终端打开即可进入该目录下 ##（2）cd 命令，切换工作目录 用法：cd 路径 切换到指定路径cd 回到家目录cd ~ 回到家目录cd . 当前目录cd .. 上级目录cd - 上次目录 1.4 常用命令—创建文件和文件夹 mkdir 创建目录 ，递归创建 添加 -p 选项touch 创建一个文件：touch 文件名touch 创建多个文件：touch filename1 filename2gedit 用来打开一个文件并进行编辑##（1）.打开一个文件后，终端进入等待状态##（2）.可以同时编辑多个文件 gedit filename1 filename2 1.4.1 常用命令- 删除文件和目录 rm -&gt;remove删除文件或者目录删除文件： rm filename此命令提供两种选项-i 以交互模式删除 （提示是否确认删除）-f 强制删除不提示删除文件夹 rm -r filename 递归删除目录中的内容 1.4.2 常用命令-文件拷贝 cp -&gt;copy用来拷贝文件或目录拷贝文件 ： cp 原路径 目标路径如： cp ./Javascript/demo.txt ./java/demo2.txt该命令提供如下选项-i 交互模式拷贝-f 强制覆盖不提示-v 显示拷贝过程-a 拷贝原有属性·拷贝目录 cp -r 源路径 目标路径 1.4.3 常用命令-移动 mv -&gt;move1.移动文件或文件夹mv 源路径 目标路径选项可选如下：-i 交互方式进行文件移动-f 强制覆盖不提示-v 显示移动过程注意：移动文件夹不需要加 -r 选项2.重命名文件及文件夹重命名： 在一个目录下移动才能进行重命名mv 旧文件名 新文件名 1.5 常用命令-其他 clear清除当前终端显示内容 如果你想秀操作的话 使用快捷键 【ctrl】+【l】 【Tab】自动补全文件夹或者文件名注意：当在当前文件夹下有相同开头文件名时，补全功能无法实现，此时按两下Tab 系统显示当前文件夹下的所有以所写命令开始的文件名 which查看某个命令所在的位置如： which gedit 终止指令的执行【ctrl】+【c】 终端字体的大小调整放大： ctrl +shift+=缩小： ctrl+ - 1.6 常用命令-日历日期 cal 查看日历cal -3 查看上月，当前月，下一月cal -y 显示当年的日历cal -j 以一年中第—天的形式显示日历cal + 具体年份 显示所写年份日历date 查看日期时间date 显示当前的年月日时分秒格式化显示date ”+%Y” 输出年份date ”+%m” 输出月份date ”+%d” 输出天date ”+%H” 输出时date ”+%M” 输出分date ”+%S” 输出秒date ”+%F” 格式化输出 如2019-7-19date ”+%T” 格式化输出 如19：56：21 1.7 常用命令-查看历史指令 history 查看当前用户服务器所有历史指令history 数量 显示一定数量的历史指令！历史指令编号 执行该条历史指令历史指令保存在~/.bash_history 文件中 1.8常用命令-文件查看（cat ,more） ·cat 查看文件或连接文件| 1.查看文件cat 文件名选项：-n 查看文件时，对每一行进行编号-b 非空行进行编号-s 连续两行以上的空行，只显示一行| 2.连接文件，把两个文件合并到 一起进行输出cat filename1 filename2·more 用来分屏查看文件内容选项：+num 从第num行开始查看文件 如：more ./demo.txt +20-p 先清屏，再查看文件-s 连续两行以上的空行，只显示一行快捷键：【enter】查看下一行【空格】查看下一屏Ctrl + f 查看下一屏Ctrl + b 查看上一屏q 退出 1.9 常用命令-数据流 、管道 ·数据流 输入流输出流标准的错误输入输出流·重定向：改变数据流向（一般定向到文件中） 重定向 以追加的方式重定向 ·管道 | 指令1 |指令2 ps:指令1必须要有输出如： touch demo.txt |more 因为指令1无输出，所以该管道使用错误","comments":true,"tags":[{"name":"Linux","slug":"Linux","permalink":"https://builtuopn.github.io/tags/Linux/"}]},{"title":"MySQL常用语句总结","date":"2021-02-04T17:15:10.000Z","path":"2021/02/05/title/","text":"查看现有数据库1SHOW DATABASE; 新建数据库1CREATE DATABASE &lt;数据库名&gt;; 选择数据库1USE &lt;数据库名&gt;; 从.sql文件引入SQL语句1SOURCE &lt;.sql文件路径&gt;; 删除数据库1DROP DATABASE &lt;数据库名&gt;; 查看当前数据库中的表1SHOW TABLES; 创建新表12345678CREATE TABLE &lt;表名&gt; (&lt;列名1&gt; &lt;列类型1&gt;,&lt;列名2&gt; &lt;列类型2&gt;,&lt;列名3&gt; &lt;列类型3&gt;,PRIMARY KEY (&lt;列名1&gt;),FOREIGN KEY (&lt;列名2&gt;) REFERENCES &lt;表名2&gt;(&lt;列名2&gt;)); 主键（PRIMARY KEY）用来标识一条记录（一行），所以每条记录的主键值必须是唯一的。主键可以定义在多列上，这称为联合主键（composite primary key）。如果我们把表视作具有某种结构的数组（例如，C语言中的struct），那么外键（FOREIGN KEY）可以视作指针 例子：123456789CREATE TABLE instructor ( ID CHAR(5), name VARCHAR(20) NOT NULL, dept_name VARCHAR(20), salary NUMERIC(8,2), PRIMARY KEY (ID), FOREIGN KEY (dept_name) REFERENCES department(dept_name) ); 在上面的例子中，我们创建了一个教员（instructor）表，该表的主键是ID，外键是教员所在的部门名称（dept_name），关联部门（department）表。此外，教员表还包括姓名（name）、薪水（salary）。其中，姓名有约束NOT NULL，表示姓名这一项不能为空。 概述表中的列使用如下语句查看表中的列的基本信息： 1DESCRIBE &lt;表名&gt;; 下图显示了一些例子：在表中插入新纪录1INSERT INTO &lt;表名&gt; (&lt;列名1&gt;, &lt;列名2&gt;, &lt;列名3&gt;, …)VALUES (&lt;值1&gt;, &lt;值2&gt;, &lt;值3&gt;, …); 在表中更新记录123UPDATE &lt;表名&gt; SET &lt;列名1&gt; = &lt;值1&gt;, &lt;列名2&gt; = &lt;值2&gt;, ... WHERE &lt;条件&gt;; 清空表1DELETE FROM &lt;表名&gt;; 删除表1DROP TABLE &lt;表名&gt;; SELECTSELECT语句可以从表中选择数据： 12SELECT &lt;列名1&gt;, &lt;列名2&gt;, …FROM &lt;表名&gt;; 以下语句选择所有内容：1SELECT * FROM &lt;表名&gt;; SELECT DISTINCTSELECT DISTINCT过滤掉了重复的值： 12SELECT DISTINCT &lt;列名1&gt;, &lt;列名2&gt;, …FROM &lt;表名&gt;; WHERE我们之前在更新记录时已经用到了WHERE关键字，用来指明条件。这里我们稍微详细一点地介绍下WHERE。WHERE的条件通常是：比较文本（text）比较数字（numbers）AND、OR、NOT等逻辑运算让我们来看一些例子： 123SELECT * FROM course WHERE dept_name=&#x27;Comp. Sci.&#x27;;SELECT * FROM course WHERE credits&gt;3;SELECT * FROM course WHERE dept_name=&#x27;Comp. Sci.&#x27; AND credits&gt;3; GROUP BYGROUP BY语句可以分组结果，常用于COUNT、MAX、MIN、SUM、AVG等聚合函数（aggregate functions）。 123SELECT &lt;列名1&gt;, &lt;列名2&gt;, …FROM &lt;表名&gt;GROUP BY &lt;列名&gt;; 让我们来看一个例子，列出每个部门的课程数量：123SELECT COUNT(course_id), dept_name FROM course GROUP BY dept_name; HAVING乍看起来，HAVING和WHERE很像： 1234SELECT &lt;列名1&gt;, &lt;列名2&gt;, …FROM &lt;表名&gt;GROUP BY &lt;列名x&gt;HAVING &lt;条件&gt;; 那么，HAVING和WHERE有什么不同呢？让我们先来看一个例子，列出开了不止一门课程的部门开设的课程数：1234 SELECT COUNT(course_id), dept_name FROM course GROUP BY dept_name HAVING COUNT(course_id)&gt;1; 这里HAVING不能换成WHERE，因为WHERE直接针对行操作，且在GROUP BY之前运行（即先通过WHERE筛选行，之后再将筛选出的行通过GROUP BY分组）。假设SQL中不存在HAVING语句，那么我们只能先新建一张表，将COUNT(course_id)作为新表的列，然后在新表上再通过WHERE进行筛选（当然，实际上SQL提供了派生表、CTE等机制，并不用真的手工建新表）。ORDER BYORDER BY可以对结果进行排序，在没有明确指定ASC（升序）或DESC（降序）的情况下，默认按升序排列。 123SELECT &lt;列名1&gt;, &lt;列名2&gt;, …FROM &lt;表名&gt;ORDER BY &lt;列名1&gt;, &lt;列名2&gt;, …, ASC|DESC; 例子：12SELECT * FROM course ORDER BY credits;SELECT * FROM course ORDER BY credits DESC; BETWEENBETWEEN语句用于指定区间。 123SELECT &lt;列名1&gt;, &lt;列名2&gt;, … FROM &lt;表名&gt; WHERE &lt;列名x&gt; BETWEEN &lt;值1&gt; AND &lt;值2&gt;; 其中“值”可能是数字，文本，乃至日期等。例如，列出薪资在50000和100000之间的教员： 1SELECT * FROM instructor WHERE salary BETWEEN 50000 AND 100000; LIKELIKE用于匹配文本中的特定模式。 123SELECT &lt;列名1&gt;, &lt;列名2&gt;, … FROM &lt;表名&gt; WHERE &lt;列名x&gt; LIKE &lt;模式&gt;; 模式中可以使用以下两个通配符：% （零个、一个或多个字符）_ （单个字符） 例子：列出课程名中包含“to”的课程，以及课程ID以“CS-”开头的课程。12SELECT * FROM course WHERE title LIKE &#x27;%to%&#x27;;SELECT * FROM course WHERE course_id LIKE &#x27;CS-___&#x27;; ININ语句表示值属于某个集合。 123SELECT &lt;列名1&gt;, &lt;列名2&gt;, … FROM &lt;表名&gt; WHERE &lt;列名n&gt; IN (&lt;值1&gt;, &lt;值2&gt;, …); 例子：列出计算机科学、物理、电子工程部门的学生。1SELECT * FROM student WHERE dept_name IN (&#x27;Comp. Sci.&#x27;, &#x27;Physics&#x27;, &#x27;Elec. Eng.&#x27;); JOINJOIN用来组合两张以上表中的值。下图展示了JOIN的三种类型： 1234SELECT &lt;列名1&gt;, &lt;列名2&gt;, … FROM &lt;表名1&gt; JOIN &lt;表名2&gt; ON &lt;表名1.列名x&gt; = &lt;表名2.列名x&gt; 让我们来看三个例子，分别对应三种JOIN的类型。第一个例子，列出课程时包含开设课程的部门详情：123SELECT * FROM course JOIN department ON course.dept_name=department.dept_name; 第二个例子，列出所有具有前置课程的课程的详情：1234SELECT prereq.course_id, title, dept_name, credits, prereq_id FROM prereq LEFT OUTER JOIN course ON prereq.course_id=course.course_id; 最后一个例子，列出所有课程的详情，不管是否具有前置课程：1234SELECT course.course_id, title, dept_name, credits, prereq_id FROM prereq RIGHT OUTER JOIN course ON prereq.course_id=course.course_id; 视图视图（view）是虚拟的SQL表。它包含行和列，和一般的SQL表格很类似。视图总是显示数据库中的最新数据。 1CREATE VIEW 创建视图：1234CREATE VIEW &lt;视图名&gt; AS SELECT &lt;列名1&gt;, &lt;列名2&gt;, … FROM &lt;表名&gt; WHERE &lt;条件&gt;; 删除视图：1DROP VIEW &lt;视图名&gt;; 例如，创建3学分的课程视图：123CREATE VIEW my_view AS SELECT * FROM course WHERE credits=3; 聚合函数我们之前已经提到聚合函数，这里列出最常用的一些聚合函数： COUNT(列名) 返回行数SUM(列名) 返回指定列的值之和AVG(列名) 返回指定列的平均值MIN(列名) 返回指定列的最小值MAX(列名) 返回指定列的最大值嵌套子查询在SQL请求中，可以嵌套SELECT-FROM-WHERE表达式，称为嵌套子查询（nested subqueries）。例如，查找2009年秋、2010年春都开的课程： 1234567SELECT DISTINCT course_id FROM section WHERE semester = ‘Fall’ AND year= 2009 AND course_id IN ( SELECT course_id FROM section WHERE semester = ‘Spring’ AND year= 2010); 创建存储过程1.基本语法：1234create procedure sp_name()begin.........end 2.参数传递调用存储过程1.基本语法：1call sp_name() 注意：存储过程名称后面必须加括号，哪怕该存储过程没有参数传递删除存储过程1.基本语法：1drop procedure sp_name 2.注意事项 不能在一个存储过程中删除另一个存储过程，只能调用另一个存储过程 区块，条件，循环1.区块定义，常用1234567begin......end;也可以给区块起别名，如：lable:begin...........end lable; 可以用leave lable;跳出区块，执行区块以后的代码2.条件语句12345if 条件 then statement else statement end if; 3.循环语句12345678(1).while循环[label:] WHILE expression DO statements END WHILE [label] ; 123456(2).loop循环[label:] LOOP statements END LOOP [label]; 12345678(3).repeat until循环[label:] REPEAT statements UNTIL expression END REPEAT [label] ; MySQL 创建存储过程 “pr_add” 是个简单的 MySQL 存储过程，这个MySQL 存储过程有两个 int 类型的输入参数 “a”、“b”，返回这两个参数的和 12345678910111213141516171819delimiter // -- 改变分割符drop procedure if exists pr_add// -- 若之前创建有这个存储过程则删除计算两个数之和create procedure pr_add (a int,b int)begindeclare c int;if a is null thenset a = 0;end if;if b is null thenset b = 0;end if;set c = a + b;select c as sum;end// 调用 MySQL 存储过程 123456call pr_add(10, 20);执行 MySQL 存储过程，存储过程参数为 MySQL 用户变量。set @a = 10;set @b = 20;call pr_add(@a, @b); MySQL 存储过程特点 创建 MySQL 存储过程的简单语法为： 1234567create procedure 存储过程名字()([in|out|inout] 参数 datatype)beginMySQL 语句;end; MySQL 存储过程参数如果不显式指定“in”、“out”、“inout”，则默认为“in”。习惯上，对于是“in” 的参数，我们都不会显式指定。1. MySQL 存储过程名字后面的“()”是必须的，即使没有一个参数，也需要“()”2. MySQL 存储过程参数，不能在参数名称前加“@”，如：“@a int”。下面的创建存储过程语法在 MySQL 中是错误的（在 SQL Server 中是正确的）。 MySQL 存储过程中的变量，不需要在变量名字前加“@”，虽然 MySQL 客户端用户变量要加个“@”。 12345create procedure pr_add(@a int, -- 错误b int -- 正确) 3. MySQL 存储过程的参数不能指定默认值。4. MySQL 存储过程不需要在 procedure body 前面加 “as”。而 SQL Server 存储过程必须加 “as” 关键字。 123456789create procedure pr_add(a int,b int)as -- 错误，MySQL 不需要 “as”beginmysql statement ...;end; 5. 如果 MySQL 存储过程中包含多条 MySQL 语句，则需要 begin end 关键字。 123456789create procedure pr_add(a int,b int)beginmysql statement 1 ...;mysql statement 2 ...;end; 6. MySQL 存储过程中的每条语句的末尾，都要加上分号 “;” 1234567...declare c int;if a is null thenset a = 0;end if;...end; 7. MySQL 存储过程中的注释。 123456declare c int; -- 这是单行 MySQL 注释 （注意 -- 后至少要有一个空格）if a is null then # 这也是个单行 MySQL 注释set a = 0;end if;...end; 8. 不能在 MySQL 存储过程中使用 “return” 关键字。 123set c = a + b;select c as sum;end; 9. 调用 MySQL 存储过程时候，需要在过程名字后面加“()”，即使没有一个参数，也需要“()” 1call pr_no_param(); 10. 因为 MySQL 存储过程参数没有默认值，所以在调用 MySQL 存储过程时候，不能省略参数。可以用 null 来替代。","comments":true,"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://builtuopn.github.io/tags/MySQL/"}]}]